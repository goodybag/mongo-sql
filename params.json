{"name":"MoSQL","tagline":"","body":"# MoSQL - SQL queries in JavaScript\r\n\r\nPut value and _semantic meaning_ back into your queries by writing your SQL as JSON:\r\n\r\n```javascript\r\nvar builder = require('mongo-sql');\r\n\r\nvar usersQuery = {\r\n  type: 'select'\r\n, table: 'users'\r\n, where: { $or: { id: 5, name: 'Bob' } }\r\n};\r\n\r\n\r\nvar result = builder.sql(usersQuery);\r\n\r\nresult.values     // Array of values\r\nresult.toString() // Sql string value\r\n```\r\n\r\n___Result:___\r\n\r\n```sql\r\nselect \"users\".* from \"users\" where \"users.id\" = $1 or \"users\".\"name\" = $2\r\n```\r\n\r\nNotice the ```$1``` and ```$2```. The outputted SQL is meant to be used in a parameterized query, like [node-pg]() performs by default.\r\n\r\n## Why JSON?\r\n\r\nThis library strives to make query composition more native to JavaScript. Using a first-class language construct means that you can easily compose and combine queries and syntax highlighting is much more meaningful than imperative counterparts.\r\n\r\n```javascript\r\nvar builder = require('mongo-sql');\r\n\r\nvar someGroup = {\r\n  type:     'select'\r\n, table:    'groups'\r\n, columns:  ['userId']\r\n, where:    { \"groupId\": 5 }\r\n}\r\n\r\nvar query = {\r\n  type:   'select'\r\n, table:  'users'\r\n, where:  { id: { $nin: someGroup } }\r\n};\r\n\r\nbuilder.sql(query);\r\n```\r\n\r\n___Result:___\r\n\r\n```sql\r\nselect \"users\".* from \"users\" where \"users\".\"id\" not in (\r\n  select \"groups\".\"userId\" from \"groups\" where  \"groups\".\"groupId\" = $1\r\n)\r\n```\r\n\r\nHow about something crazier?\r\n\r\n```javascript\r\n{\r\n  type: 'select'\r\n\r\n, columns: [ '*', 'extension.field1', 'extension.field2' ]\r\n\r\n, table: [ 'users', 'extension' ]\r\n\r\n, leftJoin: { \r\n    extension: { id: 'extension.id' }\r\n  }\r\n\r\n, where: {\r\n    name: { $ilike: { $or: ['bob', 'alice'] } }\r\n  , id: {\r\n      $nin: {\r\n        type: 'select'\r\n      , columns: ['id']\r\n      , table: 'otherUsers'\r\n      , where: { someCondition: true }\r\n      }\r\n    }\r\n  }\r\n\r\n, limit: 100\r\n\r\n, order: { id: 'desc' }\r\n\r\n, groupBy: ['id', 'name']\r\n}\r\n```\r\n\r\n___Result:___\r\n\r\n```sql\r\nselect\r\n  \"users\".*\r\n, \"extension\".\"field1\"\r\n, \"extension\".\"field2\"\r\nfrom \"users\", \"extension\"\r\n  left join \"extension\" on \"extension\".\"id\" = $1\r\nwhere (\r\n  \"users\".\"name\" ilike $2 or \"users\".\"name\" ilike $3\r\n) and \"users\".\"id\" not in (\r\n  select \"otherUsers\".\"id\" from \"otherUsers\"\r\n  where \"otherUsers\".\"someCondition\" is true\r\n)\r\nlimit $4\r\norder by \"users\".\"id\" desc\r\ngroup by \"users\".\"id\", \"users\".\"name\"\r\n```\r\n\r\n## Declarative Style and Extensibility\r\n\r\nThis library spawned from my frustrations in using popular string-building libraries for node. Other approaches require an imperative approach to string building which is just as ugly if not uglier than string concatenation and array joining.\r\n\r\n```javascript\r\nusers.select(users.id, users.name).where(\r\n  users.name.equals('Bob').and(\r\n    users.createdAt.greaterThan('2013-05-05')\r\n  )\r\n);\r\n```\r\n\r\nAt first this stuff seems great. But then as your queries get more complex you realize that it only solves the easy problems. It only solves the queries that you actually wouldn't mind just writing the string for. Swapping logic and overriding previously declared parts of your query become difficult because of the imperative style. Sub-queries and joins are awkward if supported at all and the general verbosity doesn't help either.\r\n\r\nUsing existing query builders, I found myself wanting to extend the behavior of the builder, but found no outlet to do so. I could fork the repo, implement the behavior myself, but that's no good. There needs to be a clear interface that allows anyone to add any behavior they want.\r\n\r\n### Helpers\r\n\r\nThis library is completely built on top of helpers. They're registered exactly the same way as a consumer of the library would register.\r\n\r\n#### Query Types\r\n\r\nQuery types are the base structure of a query. They provide ordering for the different components of a query. Here's a built-in query type:\r\n\r\n```javascript\r\nmongoSql.registerQueryType(\r\n  // Type identifier\r\n  'select'\r\n\r\n  // Type specification\r\n, 'select {columns} from {table} {tables} {join} {innerJoin} {leftJoin} {leftOuterJoin} {fullOuterJoin} {crossOuterJoin} {where} {limit} {offset} {order} {groupBy}'\r\n);\r\n```\r\n\r\nWhen you run a query object through the evaluator, it first checks to ensure you have specified a type. So if you used ```type: 'select'```, then the evaluator will start off with the above registered query type. Each variable enclosed in ```{``` brackets ````}``` is called a query helper. If you want to utilize a query helper, then specify a key on your query object with the appropriate value for that helper. If the query object does not specify values for a query helper, then those helpers are ignored.\r\n\r\n#### Query Helpers\r\n\r\nQuery helpers provide the strings replacements for the query helper variables in query types. In the above example, anything in ```{``` brackets ```}``` are query helpers. For example, look at the columns query helper:\r\n\r\n```javascript\r\n// helpers/query/columns.js\r\n\r\nvar helpers = require('../../lib/query-helpers');\r\nvar utils   = require('../../lib/utils');\r\n\r\nhelpers.register('columns', function(columns, values, query){\r\n  if (typeof columns != 'object') throw new Error('Invalid columns input in query properties');\r\n\r\n  var output = \"\";\r\n\r\n  if (Array.isArray(columns)){\r\n    for (var i = 0, l = columns.length; i < l; ++i)\r\n      output += utils.quoteColumn(columns[i], query.__defaultTable) + ', ';\r\n  } else {\r\n    for (var key in columns)\r\n      output += utils.quoteColumn(key, query.__defaultTable) + ' as \"' + columns[key] + '\", ';\r\n  }\r\n\r\n  if (output.length > 0) output = output.substring(0, output.length - 2);\r\n\r\n  return output;\r\n});\r\n```\r\n\r\nThe first parameter to a query helper definition is the value to the corresponding key in the query object. For a query like the one below, the columns array is passed as the first parameter.\r\n\r\n```javascript\r\n{\r\n  type: 'select'\r\n, table: 'groups'\r\n, columns: ['id', 'name']\r\n}\r\n```\r\n\r\nThe second parameter passed to query helpers is the values array for the whole sql query. This is for parameterized output.\r\n\r\n#### Conditional Helpers\r\n\r\nSome query helpers, like ```{where}``` and ```{joins}```, got so complex, I had to write a helper system just for theme. These helpers are called conditional helpers. The where and join helpers allow arbitrarily compex objects:\r\n\r\n```javascript\r\n{\r\n  type: 'select'\r\n, table: 'users'\r\n, where: {\r\n    id: {\r\n      $gt: 100, $lte: 200\r\n    , $nin: {\r\n        type: 'select'\r\n      , table: 'dumbUsers'\r\n      }\r\n    }\r\n    // Immediate children of $or are OR'd\r\n  , $or: {\r\n      $gt: { name: 'Bob' }\r\n      // But the sub-sequent children are AND'd\r\n    , $ilike: {\r\n        name: 'Pam'\r\n      , lastName: 'Sue'\r\n      }\r\n    , name: { $ilike: 'Steve' }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThings like ```$or```, ```$lte```, ```$nin``` are all conditional helpers. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}